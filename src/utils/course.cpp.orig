/**
 * \file course.cpp
 *
 * \date 03.07.2015
 * \author Moritz Nisbl√© moritz.nisble@gmx.de
 */

#include "course.hpp"

//#include <QSharedPointer>
//#include <QDataStream>
//#include <QByteArray>
#include <QCryptographicHash>
#include <QDebug>

namespace qtouch
{

Resource::Resource() :
	mBuiltin(false)
{
}

Resource::~Resource()
{
}

inline const QUuid& Resource::getId() const
{
	return mId;
}

inline void Resource::setId(const QUuid& id)
{
	mId = id;
}

inline QString Resource::getTitle() const
{
	return mTitle;
}

inline void Resource::setTitle(const QString& title)
{
	mTitle = title;
}

inline bool Resource::isBuiltin() const
{
	return mBuiltin;
}

inline void Resource::setBuiltin(bool builtin)
{
	mBuiltin = builtin;
}

void Resource::initWeakThis(const resource_ptr& thiz)
{
	mWeakThis = thiz;
}

resource_ptr Resource::sharedFromWeakThis()
{
	resource_ptr strong = mWeakThis.lock();
	return strong;
}

/* Store the back pointer to the owning object. */
inline void Resource::setParent(const resource_ptr& parent)
{
	mParent = parent;
}

Lesson::~Lesson()
{
}

void Lesson::setId(const QUuid& id)
{
	if (id.isNull())
	{
		mId = QUuid::createUuid();
		qWarning() << "Invalid UUID in lesson" << getTitle() << "Generated:" << mId.toString();
	}
	else
	{
		mId = id;
	}
}

const QString& Lesson::getNewChars() const
{
	return mNewChars;
}

void Lesson::setNewChars(const QString& newChars)
{
	mNewChars = newChars;
}

const QString& Lesson::getText() const
{
	return mText;
}

void Lesson::setText(const QString& text)
{
	mText = text;
}

/**
 * Get the Course this Lesson belongs to.
 * @note When the Course was deleted or the Lesson never belonged to a Course
 * this function returns a smart pointer to NULL.
 * @return A Course or NULL.
 */
course_ptr Lesson::getCourse() const
{
	/* Get a strong reference to the parent.
	 * This may fail, when Lessons was never added to a Course. */
	resource_ptr p = mParent.lock();
	course_ptr c;

	// But when we have a parent the cast cannot fail
	if (p)
		c = p.staticCast<course_ptr::Type>();

	return c;
}

#if 0
/**
 * Calculate the MD5 hash of a given list of Lesson.
 * @param courses A list of Lesson.
 * @return The MD5 hash.
 */
QByteArray Lesson::hash(QList<Lesson> lessons)
{
	QByteArray result;
	foreach(Lesson const & c, lessons)
	{
		result.append(c.serialize());
	}
	return QCryptographicHash::hash(result, QCryptographicHash::Md5);
}
#endif

/**
 * Serialize all members.
 * @param out An output stream.
 * @param lesson A Lesson.
 * @return The output stream.
 */
QDataStream& operator<<(QDataStream& out, const lesson_ptr& lesson)
{
	out << lesson->getId() << lesson->getTitle() << lesson->getNewChars() << lesson->isBuiltin() << lesson->getText();
	return out;
}

/**
 * Create a Course instance managed by a shared pointer.
 * @return A share pointer to the Course instance.
 */
course_ptr Course::create()
{
	/* What's going on here? ... Let me explain :)
	 * A course manages a list of lessons. Both classes inherit from Resource.
	 * To be able to later ask any Lesson for the Course it corresponds to,
	 * the Lesson must hold a reference back to its Course.
	 * Managing this is a bit tricky because we must ensure two things.
	 * 1. When the course is deleted it is not allowed to delete a Lesson that
	 * was passed out to a client. Here the solution is quite simple:
	 * Use smart pointers to store the Lessons. The Lesson is then deleted but
	 * the Lesson passed out stays valid, as long as the client holds a reference
	 * to it.
	 * 2. After the Course is deleted, the Lesson must not return the reference
	 * to the Course it belonged to, because the memory is already freed.
	 * Here we can use a weak pointer (here called "mParent").
	 * BUT: The all parent pointers stored inside the Lessons must be initialized
	 * by the same shared pointer to the Course, because they must share the same
	 * reference counter.
	 * (Rule: Never store the same address in multiple smart pointers!)
	 * So there must be a single smart pointer to the Course that can be used to
	 * initialize the parent pointers.
	 * (Note: In this case, it would be possible to use the same variable for
	 * both, weak this and weak parent pointer, because only one of them is
	 * used at the same time. But then we would use one variable for two
	 * different purposes.)
	 * This factory method ensures that there is always a shared pointer (and
	 * with a reference count of min. 1) that lives as long as the Course lives.
	 * This pointer is used to initialize the weak pointer in the base class.
	 * And that weak pointer is then used to initialize the parent pointers of
	 * the Lessons.
	 * How tricky ...
	 */
	course_ptr p(new Course);
	p->initWeakThis(p);
	return p;
}

course_ptr Course::clone(const course_ptr& org)
{
	/* Create a new course by coping the original one.
	 * After the protected constructor made a shallow copy of
	 * the object, we have to replace the lessons. */
	course_ptr p(new Course(org));
	p->initWeakThis(p);
	p->replace(org->mLessons);
	return p;
}

/* Protected: see create() */
Course::Course()
{
}

Course::Course(const course_ptr& org) :
	mDescription(org->mDescription)
{
}

Course::~Course()
{
}

void Course::setId(const QUuid& id)
{
	if (id.isNull())
	{
		mId = QUuid::createUuid();
		qWarning() << "Invalid UUID in course" << getTitle() << "Generated:" << mId.toString();
	}
	else
	{
		mId = id;
	}
}

inline const QString& Course::getDescription() const
{
	return mDescription;
}

void Course::setDescription(const QString& description)
{
	mDescription = description;
}

/**
 * Replace the Lesson container
 * @param lessons
 */
void Course::replace(const lessons_container& lessons)
{
	mLessons.clear();
	for (const_iterator it = lessons.begin(); it != lessons.end(); ++it)
	{
		append(*it);
	}
}

/**
 * Append a Lesson
 * @param lesson
 */
void Course::append(const lesson_ptr& lesson)
{
	/* Make a "deep" copy of the given lesson
	 * to not alter the parent ptr of the passed one.
	 * Its not really deep because its members are implicitly shared.
	 */
	lesson_ptr l(new Lesson(*lesson));

	resource_ptr thiz(sharedFromWeakThis());
	l->setParent(thiz);

	mLessons.append(l);
}

int Course::lessonCount() const
{
	return mLessons.size();
}

Course::iterator Course::begin()
{
	return mLessons.begin();
}

Course::iterator Course::end()
{
	return mLessons.end();
}

Course::const_iterator Course::begin() const
{
	return mLessons.begin();
}

Course::const_iterator Course::end() const
{
	return mLessons.end();
}

///**
// * Calculate the MD5 hash of this Course.
// * @return The MD5 hash.
// */
//inline QByteArray Course::hash() const
//{
//	return QCryptographicHash::hash(serialize(), QCryptographicHash::Md5);
//}

/**
 * Calculate the MD5 hash of a given list of Courses.
 * @param courses A list of Courses.
 * @return The MD5 hash.
 */
static QByteArray hash(const course_ptr& course)
{
	QByteArray buffer;
	QDataStream stream(&buffer, QIODevice::WriteOnly);
	stream << course;
	return QCryptographicHash::hash(buffer, QCryptographicHash::Md5);
}

static QByteArray hash(const course_container& courses)
{
	QByteArray buffer;
	for(course_container::const_iterator it = courses.begin(); it != courses.end(); ++it)
	{
		QDataStream stream(&buffer, QIODevice::WriteOnly);
		stream << (*it);
	}
}

/**
 * Serialize all members.
 * @param out An output stream.
 * @param lesson A Course.
 * @return The output stream.
 */
QDataStream& operator<<(QDataStream& out, const course_ptr& course)
{
	out << course->getId() << course->getTitle() << course->getDescription() << course->isBuiltin();
	for(Course::const_iterator it = course->begin(); it != course->end(); ++it)
	{
		out << (*it);
	}
	return out;
}

}/* namespace qtouch */

